\chapter{Технологический раздел}
\label{cha:impl}

\section{Требования к программному обеспечению}

\section{Средства реализации}

\section{Листинги кода}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Левенштейна (матричная реализация)]
template<typename _Word_t>
int WagnerFischer<_Word_t>::distance(_Word_t w1, int n1,
                                     _Word_t w2, int n2) {
    int **D = Util::createMatrix<int>(n1 + 1, n2 + 1);
    D[0][0] = 0;

    for (int j = 1; j <= n2; j++) {
        D[0][j] = D[0][j - 1] + insertCost;
    }

    for (int i = 1; i <= n1; i++) {
        D[i][0] = D[i - 1][0] + deleteCost;

        for (int j = 1; j <= n2; j++) {
            if (w1[i - 1] == w2[j - 1]) {
                D[i][j] = D[i - 1][j - 1];
            }
            else {
                D[i][j] = std::min(std::min(D[i - 1][j] + deleteCost,
                                            D[i][j - 1] + insertCost),
                                   D[i - 1][j - 1] + replaceCost);
            }
        }
    }

    int res = D[n1][n2];
    delete[] D;

    return res;
}
\end{lstlisting}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Дамерау-Левенштейна (матричная реализация)]
template<typename _Word_t>
int DamerauLevenshtein<_Word_t>::distance(_Word_t w1, int n1,
                                          _Word_t w2, int n2) {
    int **D = Util::createMatrix<int>(n1 + 1, n2 + 1);
    D[0][0] = 0;

    for (int j = 1; j <= n2; j++) {
        D[0][j] = D[0][j - 1] + insertCost;
    }

    for (int i = 1; i <= n1; i++) {
        D[i][0] = D[i - 1][0] + deleteCost;

        for (int j = 1; j <= n2; j++) {
            if (w1[i - 1] == w2[j - 1]) {
                D[i][j] = D[i - 1][j - 1];
            }
            else {
                D[i][j] = std::min(std::min(D[i - 1][j] + deleteCost,
                                            D[i][j - 1] + insertCost),
                                   D[i - 1][j - 1] + replaceCost);

                if (i > 1 && j > 1) {
                    if (w1[i - 1] == w2[j - 2] && w1[i - 2] == w2[j - 1]) {
                        D[i][j] = std::min(D[i - 2][j - 2] + transposeCost, D[i][j]);
                    }
                }
            }
        }
    }

    int res = D[n1][n2];
    delete[] D;

    return res;
}
\end{lstlisting}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Дамерау-Левенштейна (рекурсивная реализация)]
template<typename _Word_t>
int DamerauLevenshteinRecursive<_Word_t>::distance(_Word_t w1, int n1,
                                                   _Word_t w2, int n2) {
    if (n1 == 0) {
        return n2 * insertCost;
    }
    if (n2 == 0) {
        return n1 * deleteCost;
    }

    bool isSame = w1[n1 - 1] == w2[n2 - 1];

    int res = std::min(std::min(distance(w1, n1 - 1, w2, n2) + deleteCost,
                                distance(w1, n1, w2, n2 - 1) + insertCost),
                       distance(w1, n1 - 1, w2, n2 - 1) + replaceCost * !isSame);

    if (n1 > 1 && n2 > 1) {
        if (w1[n1 - 1] == w2[n2 - 2] && w1[n1 - 2] == w2[n2 - 1]) {
            res = std::min(distance(w1, n1 - 2, w2, n2 - 2) + transposeCost, res);
        }
    }

    return res;
}
\end{lstlisting}
\end{minipage}

\section{Описание тестирования}

