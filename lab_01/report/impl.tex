\chapter{Технологический раздел}
\label{cha:impl}

\section{Требования к программному обеспечению}
Требования к вводу:
\begin{itemize}
    \item На вход подаются две строки, разделённые переносом строки;
    \item Одна и та же буква в верхнем и нижнем регистрах считается как разные символы;
    \item Пустая строка может быть введена.
\end{itemize}
Требования к выводу:
\begin{itemize}
    \item Редакционное расстояние;
    \item В случае матричной реализации алгоритма выводить матрицу, полученную в ходе вычисления расстояния.
\end{itemize}
Требования к программе:
\begin{itemize}
    \item Выбор алгоритма происходит через аргументы командной строки.
\end{itemize}

\section{Средства реализации}
Для реализации программы вычисления редакционного расстояния мной был выбран язык программирования C++. В рамках текущей задачи данный язык программирования имеет ряд существенных преимуществ:
\begin{itemize}
    \item Статическая типизация;
    \item Близость к низкоуровневому C при наличии многих возможностей высокоуровневых языков;
    \item Встроенная библиотека std::chrono, позовляющая измерять процессорное время.
\end{itemize}

\section{Листинги кода}
Реализации алгоримтов Вагнера-Фишера и матричной и рекурсивной вариаций Дамерау-Левенштейна приведены в листингах 3.1, 3.2, 3.3 соответственно.

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Левенштейна (матричная реализация)]
template<typename _Word_t>
int WagnerFischer<_Word_t>::distance(_Word_t w1, int n1,
                                     _Word_t w2, int n2) {
    int **D = Util::createMatrix<int>(n1 + 1, n2 + 1);
    D[0][0] = 0;

    for (int j = 1; j <= n2; j++) {
        D[0][j] = D[0][j - 1] + insertCost;
    }

    for (int i = 1; i <= n1; i++) {
        D[i][0] = D[i - 1][0] + deleteCost;

        for (int j = 1; j <= n2; j++) {
            if (w1[i - 1] == w2[j - 1]) {
                D[i][j] = D[i - 1][j - 1];
            }
            else {
                D[i][j] = std::min(std::min(D[i - 1][j] + deleteCost,
                                            D[i][j - 1] + insertCost),
                                   D[i - 1][j - 1] + replaceCost);
            }
        }
    }

    int res = D[n1][n2];
    delete[] D;

    return res;
}
\end{lstlisting}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Дамерау-Левенштейна (матричная реализация)]
template<typename _Word_t>
int DamerauLevenshtein<_Word_t>::distance(_Word_t w1, int n1,
                                          _Word_t w2, int n2) {
    int **D = Util::createMatrix<int>(n1 + 1, n2 + 1);
    D[0][0] = 0;

    for (int j = 1; j <= n2; j++) {
        D[0][j] = D[0][j - 1] + insertCost;
    }

    for (int i = 1; i <= n1; i++) {
        D[i][0] = D[i - 1][0] + deleteCost;

        for (int j = 1; j <= n2; j++) {
            if (w1[i - 1] == w2[j - 1]) {
                D[i][j] = D[i - 1][j - 1];
            }
            else {
                D[i][j] = std::min(std::min(D[i - 1][j] + deleteCost,
                                            D[i][j - 1] + insertCost),
                                   D[i - 1][j - 1] + replaceCost);

                if (i > 1 && j > 1) {
                    if (w1[i - 1] == w2[j - 2] && w1[i - 2] == w2[j - 1]) {
                        D[i][j] = std::min(D[i - 2][j - 2] + transposeCost,
                                           D[i][j]);
                    }
                }
            }
        }
    }

    int res = D[n1][n2];
    delete[] D;

    return res;
}
\end{lstlisting}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Расстояние Дамерау-Левенштейна (рекурсивная реализация)]
template<typename _Word_t>
int DamerauLevenshteinRecursive<_Word_t>::distance(_Word_t w1, int n1,
                                                   _Word_t w2, int n2) {
    if (n1 == 0) {
        return n2 * insertCost;
    }
    if (n2 == 0) {
        return n1 * deleteCost;
    }

    bool isSame = w1[n1 - 1] == w2[n2 - 1];

    int res = std::min(std::min(distance(w1, n1 - 1, w2, n2) + deleteCost,
                                distance(w1, n1, w2, n2 - 1) + insertCost),
                       distance(w1, n1 - 1, w2, n2 - 1) + replaceCost *
                                                          !isSame);

    if (n1 > 1 && n2 > 1) {
        if (w1[n1 - 1] == w2[n2 - 2] && w1[n1 - 2] == w2[n2 - 1]) {
            res = std::min(distance(w1, n1 - 2, w2, n2 - 2) +
                           transposeCost, res);
        }
    }

    return res;
}
\end{lstlisting}
\end{minipage}

\section{Описание тестирования}
Для тестирования программы были подготовлены данные, предствленные в таблицe 3.1.

\begin{table}[H]
    \caption{Тестовые данные}
	\begin{tabular}{|c|c|c|c|c|}
 	\hline
    \No{} & Строка 1 & Строка 2 & \makecell{Ожидаемое расстояние\\Левенштейна} & \makecell{Ожидаемое расстояние\\Дамерау-Левенштейна} \\
 	\hline
 	1 & some & any & 4 & 4\\
 	\hline
 	2 & man & person & 6 & 6\\
 	\hline
 	3 & & nothing & 7 & 7\\
 	\hline
 	4 & & & 0 & 0\\
 	\hline
 	5 & bashrc & bashcr & 2 & 1\\
 	\hline
 	6 & goose & duck & 5 & 5\\
 	\hline
 	7 & bus & BuS & 2 & 2\\
 	\hline
 	8 & electricity & city & 7 & 7\\
 	\hline
 	9 & powerfull & powerless & 4 & 4\\
 	\hline
 	10 & grow & flow & 2 & 2\\
 	\hline
 	11 & rise & rice & 1 & 1\\
 	\hline
 	12 & fake & lake & 1 & 1\\
 	\hline
    13 & same & same & 0 & 0\\
    \hline
	\end{tabular}
\end{table}

